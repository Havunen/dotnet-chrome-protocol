// <auto-generated />
#nullable enable

using ChromeProtocol.Core;

namespace ChromeProtocol.Domains
{
  public static partial class Preload
  {
    /// <summary>Unique id</summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record RuleSetIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Corresponds to SpeculationRuleSet</summary>
    /// <param name="LoaderId">Identifies a document which the rule set is associated with.</param>
    /// <param name="SourceText">
    /// Source text of JSON representing the rule set. If it comes from<br/>
    /// `&lt;script&gt;` tag, it is the textContent of the node. Note that it is<br/>
    /// a JSON for valid case.<br/>
    /// See also:<br/>
    /// - https://wicg.github.io/nav-speculation/speculation-rules.html<br/>
    /// - https://github.com/WICG/nav-speculation/blob/main/triggers.md<br/>
    /// </param>
    /// <param name="BackendNodeId">
    /// A speculation rule set is either added through an inline<br/>
    /// `&lt;script&gt;` tag or through an external resource via the<br/>
    /// &#39;Speculation-Rules&#39; HTTP header. For the first case, we include<br/>
    /// the BackendNodeId of the relevant `&lt;script&gt;` tag. For the second<br/>
    /// case, we include the external URL where the rule set was loaded<br/>
    /// from, and also RequestId if Network domain is enabled.<br/>
    /// See also:<br/>
    /// - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script<br/>
    /// - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header<br/>
    /// </param>
    /// <param name="ErrorType">
    /// Error information<br/>
    /// `errorMessage` is null iff `errorType` is null.<br/>
    /// </param>
    /// <param name="ErrorMessage">TODO(https://crbug.com/1425354): Replace this property with structured error.</param>
    public record RuleSetType(
      [property: Newtonsoft.Json.JsonProperty("id")]
      ChromeProtocol.Domains.Preload.RuleSetIdType Id,
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: Newtonsoft.Json.JsonProperty("sourceText")]
      string SourceText,
      [property: Newtonsoft.Json.JsonProperty("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string? Url = default,
      [property: Newtonsoft.Json.JsonProperty("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType? RequestId = default,
      [property: Newtonsoft.Json.JsonProperty("errorType")]
      ChromeProtocol.Domains.Preload.RuleSetErrorTypeType? ErrorType = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("errorMessage")]
      string? ErrorMessage = default
    ) : ChromeProtocol.Core.IType
    {
    }
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record RuleSetErrorTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// The type of preloading attempted. It corresponds to<br/>
    /// mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it<br/>
    /// isn&#39;t being used by clients).<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record SpeculationActionType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Corresponds to mojom::SpeculationTargetHint.<br/>
    /// See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record SpeculationTargetHintType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// A key that identifies a preloading attempt.<br/>
    /// The url used is the url specified by the trigger (i.e. the initial URL), and<br/>
    /// not the final url that is navigated to. For example, prerendering allows<br/>
    /// same-origin main frame navigations during the attempt, but the attempt is<br/>
    /// still keyed with the initial URL.<br/>
    /// </summary>
    public record PreloadingAttemptKeyType(
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: Newtonsoft.Json.JsonProperty("action")]
      ChromeProtocol.Domains.Preload.SpeculationActionType Action,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("targetHint")]
      ChromeProtocol.Domains.Preload.SpeculationTargetHintType? TargetHint = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Lists sources for a preloading attempt, specifically the ids of rule sets<br/>
    /// that had a speculation rule that triggered the attempt, and the<br/>
    /// BackendNodeIds of &lt;a href&gt; or &lt;area href&gt; elements that triggered the<br/>
    /// attempt (in the case of attempts triggered by a document rule). It is<br/>
    /// possible for mulitple rule sets and links to trigger a single attempt.<br/>
    /// </summary>
    public record PreloadingAttemptSourceType(
      [property: Newtonsoft.Json.JsonProperty("key")]
      ChromeProtocol.Domains.Preload.PreloadingAttemptKeyType Key,
      [property: Newtonsoft.Json.JsonProperty("ruleSetIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Preload.RuleSetIdType> RuleSetIds,
      [property: Newtonsoft.Json.JsonProperty("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.BackendNodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>List of FinalStatus reasons for Prerender2.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record PrerenderFinalStatusType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Preloading status values, see also PreloadingTriggeringOutcome. This<br/>
    /// status is shared by prefetchStatusUpdated and prerenderStatusUpdated.<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record PreloadingStatusType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and<br/>
    /// filter out the ones that aren&#39;t necessary to the developers.<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record PrefetchStatusType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Upsert. Currently, it is only emitted when a rule set added.</summary>
    [ChromeProtocol.Core.MethodName("Preload.ruleSetUpdated")]
    public record RuleSetUpdated(
      [property: Newtonsoft.Json.JsonProperty("ruleSet")]
      ChromeProtocol.Domains.Preload.RuleSetType RuleSet
    ) : ChromeProtocol.Core.IEvent
    {
    }
    [ChromeProtocol.Core.MethodName("Preload.ruleSetRemoved")]
    public record RuleSetRemoved(
      [property: Newtonsoft.Json.JsonProperty("id")]
      ChromeProtocol.Domains.Preload.RuleSetIdType Id
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when a preload enabled state is updated.</summary>
    [ChromeProtocol.Core.MethodName("Preload.preloadEnabledStateUpdated")]
    public record PreloadEnabledStateUpdated(
      [property: Newtonsoft.Json.JsonProperty("disabledByPreference")]
      bool DisabledByPreference,
      [property: Newtonsoft.Json.JsonProperty("disabledByDataSaver")]
      bool DisabledByDataSaver,
      [property: Newtonsoft.Json.JsonProperty("disabledByBatterySaver")]
      bool DisabledByBatterySaver,
      [property: Newtonsoft.Json.JsonProperty("disabledByHoldbackPrefetchSpeculationRules")]
      bool DisabledByHoldbackPrefetchSpeculationRules,
      [property: Newtonsoft.Json.JsonProperty("disabledByHoldbackPrerenderSpeculationRules")]
      bool DisabledByHoldbackPrerenderSpeculationRules
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when a prefetch attempt is updated.</summary>
    /// <param name="InitiatingFrameId">The frame id of the frame initiating prefetch.</param>
    [ChromeProtocol.Core.MethodName("Preload.prefetchStatusUpdated")]
    public record PrefetchStatusUpdated(
      [property: Newtonsoft.Json.JsonProperty("key")]
      ChromeProtocol.Domains.Preload.PreloadingAttemptKeyType Key,
      [property: Newtonsoft.Json.JsonProperty("initiatingFrameId")]
      ChromeProtocol.Domains.Page.FrameIdType InitiatingFrameId,
      [property: Newtonsoft.Json.JsonProperty("prefetchUrl")]
      string PrefetchUrl,
      [property: Newtonsoft.Json.JsonProperty("status")]
      ChromeProtocol.Domains.Preload.PreloadingStatusType Status,
      [property: Newtonsoft.Json.JsonProperty("prefetchStatus")]
      ChromeProtocol.Domains.Preload.PrefetchStatusType PrefetchStatus,
      [property: Newtonsoft.Json.JsonProperty("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when a prerender attempt is updated.</summary>
    /// <param name="DisallowedMojoInterface">
    /// This is used to give users more information about the name of Mojo interface<br/>
    /// that is incompatible with prerender and has caused the cancellation of the attempt.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Preload.prerenderStatusUpdated")]
    public record PrerenderStatusUpdated(
      [property: Newtonsoft.Json.JsonProperty("key")]
      ChromeProtocol.Domains.Preload.PreloadingAttemptKeyType Key,
      [property: Newtonsoft.Json.JsonProperty("status")]
      ChromeProtocol.Domains.Preload.PreloadingStatusType Status,
      [property: Newtonsoft.Json.JsonProperty("prerenderStatus")]
      ChromeProtocol.Domains.Preload.PrerenderFinalStatusType? PrerenderStatus = default,
      [property: Newtonsoft.Json.JsonProperty("disallowedMojoInterface")]
      string? DisallowedMojoInterface = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Send a list of sources for all preloading attempts in a document.</summary>
    [ChromeProtocol.Core.MethodName("Preload.preloadingAttemptSourcesUpdated")]
    public record PreloadingAttemptSourcesUpdated(
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: Newtonsoft.Json.JsonProperty("preloadingAttemptSources")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Preload.PreloadingAttemptSourceType> PreloadingAttemptSources
    ) : ChromeProtocol.Core.IEvent
    {
    }
    public static ChromeProtocol.Domains.Preload.EnableRequest Enable()    
    {
      return new ChromeProtocol.Domains.Preload.EnableRequest();
    }
    [ChromeProtocol.Core.MethodName("Preload.enable")]
    public record EnableRequest() : ChromeProtocol.Core.ICommand<EnableRequestResult>
    {
    }
    public record EnableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    public static ChromeProtocol.Domains.Preload.DisableRequest Disable()    
    {
      return new ChromeProtocol.Domains.Preload.DisableRequest();
    }
    [ChromeProtocol.Core.MethodName("Preload.disable")]
    public record DisableRequest() : ChromeProtocol.Core.ICommand<DisableRequestResult>
    {
    }
    public record DisableRequestResult() : ChromeProtocol.Core.IType
    {
    }
  }
}
